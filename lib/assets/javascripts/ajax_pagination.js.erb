//= require jquery.ba-bbq
//= require jquery.url

/* 
 * AJAX Pagination: Ajaxifying your pagination links
 * https://github.com/ronalchn/ajax_pagination
 * 
 * Copyright (c) 2012 Ronald Ping Man Chan
 * Distributed under the LGPL license
 *
 * Although the ajax_pagination gem as a whole is distributed under LGPL, I am expressly permitting users to minify and concatenate this javascript file
 * with other javascript files, as long as it is through an automatic asset management process (eg. Sprockets), and the automatic asset
 * management process obtains this javascript file as a separate file via dynamically linked means (ie. with this file left in the separately
 * installed ajax_pagination gem).
 *    ~ Ronald Chan
 */
jQuery(document).ready(function () {
  function minVersion(version) {
    var $vrs = window.jQuery.fn.jquery.split('.'),
        min  = version.split('.');
    for (var i=0, len=min.length; i<len; i++) {
      if ($vrs[i]) {
        min[i] = parseInt(min[i],10);
        $vrs[i] = parseInt($vrs[i],10);
        if ($vrs[i] < min[i]) return false;
        else if ($vrs[i] > min[i]) return true;
      }
      else return false;
    }
    return true;
  }
  <% minjQuery = '1.7' %>
  <% if AjaxPagination.warnings %>
    if (!(History && minVersion('<%= minjQuery %>'))) { // dependencies missing
      var missing = "";
      if (!History) missing += "\nHistory.js not installed";
      if (!minVersion('<%= minjQuery %>')) missing += "\njQuery version <%= minjQuery %>+ not installed. Currently installed: jQuery " + window.jQuery.fn.jquery;
      alert("AJAX Pagination warning:" + missing);
    }
  <% end %>
  if (History && History.enabled && minVersion('<%= minjQuery %>')) {
    (function( $ ) {
      ///////////////////////////////////
      ////// $.ajax_pagination API //////
      ///////////////////////////////////
      // selector function for pagination object
      $.ajax_pagination = function (pagination_name) {
        return new pagination_object(pagination_name);
      };
      $.ajax_pagination.version = '<%= AjaxPagination::VERSION %>';
      function pagination_object(pagination_name) {
        this.get = function(url,options) {
          if (options === undefined) options = {};
          if (options.history === undefined) options.history = true;
          swapPage(pagination_name,url,options.history);
        }
        this.exists = function() {
          return $('#' + pagination_name + '_paginated_section').length == 1;
        }
      }
      /////////////////////////////
      ////// Basic Internals //////
      /////////////////////////////
      var pagination_loader_state = new Array(); // the page we are waiting for
      var pagination_url = location.href; // url we came from, so we can see transitions of the url

      function display_pagination_loader(pagination_name) {
        if (pagination_loader_state[pagination_name] != undefined) return; // if already loading, don't reshow loader
        var paginated_section = $('#' + pagination_name + '_paginated_section');
        var paginated_content;
        if (paginated_section.hasClass("paginated_content")) paginated_content = paginated_section; // if the whole section is a loading zone
        else paginated_content = paginated_section.children(".paginated_content").first(); // don't want to support multiple loader images
        var height = paginated_content.height();
        // setup loading look
        var img = document.createElement("IMG");
        if (paginated_section.data("pagination") !== undefined && paginated_section.data("pagination").image !== undefined) img.src = paginated_section.data("pagination").image;
        else img.src = "<%= asset_path AjaxPagination.loading_image %>";
        var margin = Math.round(height>400?50:(height/8));
        $(img).addClass('ajaxpagination-loader');
        var div = document.createElement("DIV");
        $(div).addClass('ajaxpagination-loadzone');
        $(div).append("<div class=\"margin-top\" />").append(img);
        paginated_content.wrapInner("<div class=\"ajaxpagination-oldcontent\" />");
        paginated_content.append(div);

        // scroll to top of paginated_section if it is not visible
        if ($(document).scrollTop() > paginated_section.offset().top - <%= AjaxPagination.scroll_margin %>) {
          $(document).scrollTop(paginated_section.offset().top - <%= AjaxPagination.scroll_margin %>);
        }
      }
      // when this function is used beforeSend of an AJAX request, will use the resulting content in a section of the page
      // this event handler has the same arguments as for jquery and jquery-ujs, except it also takes the name of the section to put the content into as first argument
      // adapter functions will be used to reconcile the differences in arguments, this is required because jquery and jquery-ujs has different ways to get the pagination_name argument
      function beforeSendHandler(pagination_name,jqXHR,settings) {
        var id = "#" + pagination_name + "_paginated_section"; // element id we are looking for
        var requesturl = settings.url;
        if ($(id).length != 1) { // something wrong, cannot find unique section to load page into
          <% if AjaxPagination.warnings %>
            alert("AJAX Pagination warning:\nExpected one pagination section called " + pagination_name + ", found " + $("#" + pagination_name + "_paginated_section").length);
          <% end %>
          return false; // continue AJAX normally
        }
        display_pagination_loader(pagination_name);
        // register callbacks for other events
        jqXHR.done(function(data, textStatus, jqXHR) {
          if (requesturl != pagination_loader_state[pagination_name]) return; // ignore stale content
          if (jqXHR.status == 200 && jqXHR.getResponseHeader('Location') !== null) { // special AJAX redirect
            var redirecturl = jqXHR.getResponseHeader('Location');
            swapPage(pagination_name,redirecturl);
            pagination_url = redirecturl;
            History.replaceState(null,document.title,redirecturl);
            return;
          }
          // find matching element id in data, after removing script tags
          var page = $("<div />").append(data.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,""));
          var content = page.find(id);
          if (content.length>0) {
            $(id).html(content.html());
            <% if AjaxPagination.warnings %>
              alert("AJAX Pagination warning:\nExtra content returned by AJAX request ignored. Only a portion of the page content returned by the server was required. To fix this, explicitly call ajax_pagination for :pagination => \"" + pagination_name + "\" to render only the partial view required. This warning can be turned off in the ajax_pagination initializer file.");
            <% end %>
          }
          else { // otherwise use all the content, including any scripts - we consider scripts specifically returned in the partial probably should be re-run
            page = $("<div />").append(data);
            content = page.find("body");
            if (content.length>0) $(id).html(content.html()); // if it has a body tag, only include its contents (for full html structure), leaving out <head> etc sections.
            else $(id).html(page.html()); // otherwise include the whole html snippet
          }
          // if page contains a title, use it
          content = page.find("title");
          if (content.length>0) History.replaceState(null,content.html(),location.href);
          delete pagination_loader_state[pagination_name]; // not waiting for page anymore
        });
        jqXHR.fail(function(jqXHR, textStatus, errorThrown) {
          if (requesturl != pagination_loader_state[pagination_name]) return; // ignore stale content
          $(id).html(jqXHR.responseText);
          delete pagination_loader_state[pagination_name]; // not waiting for page anymore
        });
        return true;
      }
      function swapPage(pagination_name, requesturl, history) { // swaps the page at pagination_name to that from requesturl (used by History.popState, therefore no remote link has been clicked)
        if (history === undefined) history = false;
        // send our own ajax request, and tie it into the beforeSendHandler used for jquery-ujs as well
        $.ajax({url: requesturl, data: {pagination:pagination_name},
          dataType: 'html',
          beforeSend: function (jqXHR,settings) {
            var result = beforeSendHandler(pagination_name,jqXHR,settings);
            if (result) {
              if (history) pushHistory(pagination_name,settings.url);
              pagination_loader_state[pagination_name] = settings.url; // remember which page number we are waiting for
            }
            return result;
          }
        });
      }
      function pushHistory(pagination_name,url) {
        var data = $("#" + pagination_name + "_paginated_section").data("pagination");
        if (data === undefined || data.history === undefined || data.history) {
          var data = $.deparam.querystring($.url(url).attr('query'));
          delete data['pagination'];
          pagination_url = $.param.querystring(url,data,2);
          History.pushState(null,document.title,pagination_url);
        }
      }
      // these special containers are for convenience only, to apply the required data-remote, data-pagination attributes to all links inside
      $(document).on("click", ".pagination a, .ajaxpagination a, a.ajaxpagination", function(e) {
        // ignore if already selected by jquery-ujs
        if ($(this).filter($.rails.linkClickSelector).length>0) return true; // continue with jquery-ujs - this behaviour is necessary because we do not know if the jquery-ujs handler executes before or after this handler
        // find out what data-pagination should be set to
        var pagination_container = $(this).closest(".pagination, .ajaxpagination"); // container of links (use to check for data-pagination first)
        var pagination_name = pagination_container.data('pagination');
        if (pagination_name === undefined) {
          pagination_name = /^(.*)_paginated_section$/.exec($(this).closest(".paginated_section").attr("id")); // if data-pagination not present, search up the tree for a suitable section
          if (pagination_name == null) {
            <% if AjaxPagination.warnings %>
              alert("AJAX Pagination warning:\nNo pagination section name given for link, and none could be implicitly assigned, AJAX cancelled for this request");
            <% end %>
            return true; // pagination not set up properly
          }
          pagination_name = pagination_name[1];
        }
        
        // set data-remote, data-pagination
        $(this).attr({'data-remote':'true'}); // needs to be set so that the jquery-ujs selectors work
        $(this).data({'remote':'true','pagination':pagination_name}); // needs to be set because attributes only read into jquery's data memory once
        if ($(this).data('type') === undefined) { // to be moved to ajax:before filter when https://github.com/rails/jquery-ujs/pull/241 is successful, and jquery-rails minimum version updated
          $(this).data('type','html'); // AJAX Pagination requests return html be default
        }
        // stop this event from having further effect (because we do not know if jquery-ujs's event handler executed before or after us)
        e.preventDefault();
        e.stopImmediatePropagation();
        // click element again to dispatch the event all over again - thus ensuring it is handled by jquery-ujs
        $(this).click();
        return false;
      });
      $(document).on("ajax:before","a, " + $.rails.inputChangeSelector, function() {
        var pagination_name = $(this).data('pagination');
        if (pagination_name === undefined) return true; // this is not an AJAX Pagination AJAX request
        $(this).data('params',$.extend($(this).data('params'),{'pagination':pagination_name})); // add data-pagination to the params data
        return true;
      });
      $(document).on("ajax:before","form", function() {
        // alter action to include pagination parameter in the GET part of the action url
        $(this).attr('action',$.param.querystring($(this).attr('action'),{pagination:$(this).data('pagination')}));
      });
      $(document).on("ajax:beforeSend","a, form, " + $.rails.inputChangeSelector, function (e,jqXHR,settings) {
        var pagination_name = $(this).data('pagination');
        if (pagination_name === undefined) return true; // this is not an AJAX Pagination AJAX request
        if (beforeSendHandler(pagination_name,jqXHR,settings)) {
          pushHistory(pagination_name,settings.url);
          pagination_loader_state[pagination_name] = settings.url;
        }
        return true;
      });

      History.Adapter.bind(window,'popstate',function(){ // popstate, but can work with hash changes as well
        var from = pagination_url, to = location.href; // from what state to what other state

        $(".paginated_section").each(function(){
          var pagination_name = /^(.*)_paginated_section$/.exec($(this).attr("id"))[1];
          if (pagination_name == null) return; // pagination not set up properly

          // if data-pagination is not defined, the use default reload test
          if ($(this).data('pagination') === undefined || $(this).data('pagination').reload === undefined) {
            // if ?pagination_name=ABC, where ABC is the same for both urls, then don't need to reload
            if ($.deparam.querystring(from)[pagination_name] === $.deparam.querystring(to)[pagination_name]) return;
          }
          else { // otherwise parse json and perform tests
            var reload = $(this).data('pagination').reload;
            if (!(reload instanceof Array)) reload = new Array(reload);
            var changed = false;
            for (i=0;i<reload.length;i++) {
              if (reload[i].query !== undefined) {
                if ($.deparam.querystring(from)[reload[i].query] !== $.deparam.querystring(to)[reload[i].query]) changed = true;
              }
              if (reload[i].urlregex !== undefined) {
                var fstr = from, tstr = to;
                if (reload[i].urlpart !== undefined) {
                  fstr = $.url(from,true).attr(reload[i].urlpart);
                  tstr = $.url(to,true).attr(reload[i].urlpart);
                  if (typeof(fstr)!="string" || typeof(tstr)!="string") continue; // skip
                }
                var index = 0;
                if (reload[i].regexindex !== undefined) index = reload[i].regexindex;
                var regex = new RegExp(reload[i].urlregex);
                var frommatch = regex.exec(fstr), tomatch = regex.exec(tstr);
                if (frommatch != null && frommatch.length>=index) frommatch = frommatch[index];
                if (tomatch != null && tomatch.length>=index) tomatch = tomatch[index];
                if (frommatch !== tomatch) changed = true;
              }
              if (changed) break;
            }
            if (!changed) return; // otherwise it has changed, and we must reload
          }
          swapPage(pagination_name,location.href);
        });

        pagination_url = location.href; // update url (new url recognised)
      });

      History.Adapter.trigger(window,"popstate"); // update stuff on page load
    })( jQuery );
  }
});

